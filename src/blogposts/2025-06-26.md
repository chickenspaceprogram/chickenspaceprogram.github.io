\def{title}{Good-Bad Go}
# Go is a good-bad language

Author: Athena Boose\\
Date: 2025-06-27

I should preface this by stating that I'm still fairly new to Go.
This is more a novice's first impressions than the opinion of someone who
knows what they're talking about. That aside,

### What do I mean by this?

I don't really mean that Go has some nice parts and some bad parts.
That's certainly true, but it's also true of every language ever.

Instead, I mean that Go has features that are simultaneously good and bad.

For example, returning NULL (or nil, I guess).
Returning NULL is, in my view, fundamentally flawed on some level. 

You automatically lose the ability to be relatively certain the code won't
panic somewhere random, something you'd usually get with sum types and pattern
matching (unless you're doing Haskell, where forgetting a branch of a pattern
match is the bane of my existence).

But, it's convenient and readable. Yeah, Haskell has monads and Rust has
the `?` operator, but I always have to think for two seconds about the flow
of the code with either of those. (Maybe this is inexperience.)
The `if result == nil` check after calling a function is more readable, at the
cost of being more verbose.
I don't have to think, I know what it does.

And, in any case, in Rust, you'd probably need a match or if-let expression if
the error does anything more than return back up the call stack. Your code is
just as ugly.

I mean this when I call Go good-bad. It takes the easy, obvious, 
slightly-less-optimal route because fuck it. 
If you wanted proper code you'd pick another language.

Yeah, goroutines run concurrently, and you'll occasionally have to throw some
mutexes around your code, costing you performance and sanity.

But, it beats having to have special handling for file IO in the standard
library (since, unlike network IO, most OSes don't provide any way to do that
asynchronously). And you can still provide channels, which often obviate the
need for mutexes.

Yeah, all the files in a directory get put in the same package, without 
namespacing.

But hey, there's no includes or module declarations necessary, and you probably
weren't going to have name collisions anyways.

There is a garbage collector, which isn't optimal, but at least I don't have
to remember to free things, write the destructor correctly, or get yelled at
by a strict type system.

Hopefully you see the point.

I'm sure in a large project these sorts of features would get irritating, but
for the things Go is designed to do they're great.

If the code is a thousand lines or less it's trivial to test it to make sure
it doesn't segfault. I can just rename things if they collide, and it's not
like the shitty code I threw together on a weekend will have enough users to
care if it's slower than optimal.

It's the perfect 80/20 language. You put in just enough effort to make it work,
then move on with your life and do something else.

